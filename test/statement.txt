# Variable declaration

var a = b
  , c = d;
const [x] = y = 3;

==>

VariableDeclaration(Keyword, Definition, Operator, Variable, Definition, Operator, Variable),
VariableDeclaration(Keyword, ArrayPattern(Definition), Operator, AssignmentExpression(Variable, Operator, Number))

# Function declaration

function a(a, b) { return 3; }
function b({b}, c = d, e = f) {}

==>

FunctionDeclaration(Keyword, Definition, ParamList(Definition, Definition), Block(ReturnStatement(Keyword, Number))),
FunctionDeclaration(Keyword, Definition, ParamList(
  ObjectPattern(Property(PropertyName)),
  Definition, Operator, Variable,
  Definition, Operator, Variable), Block)

# Async functions

async function foo() {}

class Foo { async bar() {} }

async (a) => { return foo; };

==>

FunctionDeclaration(Keyword, Keyword, Definition, ParamList, Block),
ClassDeclaration(Keyword, Definition, ClassBody(MethodDefinition(Keyword, PropertyName, ParamList, Block))),
ArrowFunction(Keyword, ParamList(Definition), Block(ReturnStatement(Keyword, Variable)))

# If statements

if (x) log(y);

if (a.b) {
  d;
}

if (a) {
  c;
  d;
} else {
  e;
}

if (1) if (2) b; else c;

==>

IfStatement(Keyword, Variable, CallExpression(Variable, ArgList(Variable))),

IfStatement(Keyword, MemberExpression(Variable, PropertyName), Block(Variable)),

IfStatement(Keyword, Variable, Block(Variable, Variable), Keyword, Block(Variable)),

IfStatement(Keyword, Number, IfStatement(Keyword, Number, Variable, Keyword, Variable))

# While loop

while (1) debugger;
while (2) {
  a;
  b;
}

==>

WhileStatement(Keyword, Number, DebuggerStatement(Keyword)),
WhileStatement(Keyword, Number, Block(Variable, Variable))

# Labels

foo: 1;
foo: while(2) break foo;

==>

LabeledStatement(Label, Number),
LabeledStatement(Label, WhileStatement(Keyword, Number, BreakStatement(Keyword, Label)))

# Try

try { throw new Error; } catch {}
try { 1; } catch (x) { 2; } finally { 3; }

==>

TryStatement(Keyword, Block(ThrowStatement(Keyword, NewExpression(Keyword, Variable))), Keyword, Block),
TryStatement(Keyword, Block(Number), Keyword, Definition, Block(Number), Keyword, Block(Number))

# Switch

switch (x) {
  case 1:
    return true;
  case 2:
  case 50 * 3:
    console.log("ok");
  default:
    return false;
}

==>

SwitchStatement(
  Keyword,
  Variable,
  Block(
    SwitchCase(Keyword, Number),
    ReturnStatement(Keyword, Boolean),
    SwitchCase(Keyword, Number),
    SwitchCase(Keyword, BinaryExpression(Number, Operator, Number)),
    CallExpression(MemberExpression(Variable, PropertyName), ArgList(String)),
    SwitchDefault(Keyword),
    ReturnStatement(Keyword, Boolean)))

# For

for (let x = 1; x < 10; x++) {}
for (const y of z) {}
for (var m in n) {}
for (q in r) {}
for (var a, b; c; d) continue;
for (i = 0, init(); i < 10; i++) {}
for (;;) {}
for (const {thing} in things) thing;
for await (let x of stream) {}

==>

ForStatement(Keyword,
             VariableDeclaration(Keyword, Definition, Operator, Number),
             BinaryExpression(Variable, Operator, Number),
             UnaryExpression(Variable, Operator),
             Block),
ForStatement(Keyword, LoopDeclaration(Keyword, Definition, Keyword, Variable), Block),
ForStatement(Keyword, LoopDeclaration(Keyword, Definition, Keyword, Variable), Block),
ForStatement(Keyword, LoopDeclaration(Variable, Keyword, Variable), Block),
ForStatement(Keyword, VariableDeclaration(Keyword, Definition, Definition), Variable, Variable, ContinueStatement(Keyword)),
ForStatement(Keyword, SequenceExpression(AssignmentExpression(Variable, Operator, Number), CallExpression(Variable, ArgList)),
             BinaryExpression(Variable, Operator, Number), UnaryExpression(Variable, Operator), Block),
ForStatement(Keyword, Block),
ForStatement(Keyword, LoopDeclaration(Keyword, ObjectPattern(Property(PropertyName)), Keyword, Variable), Variable),
ForStatement(Keyword, Keyword, LoopDeclaration(Keyword, Definition, Keyword, Variable), Block)

# Labeled statements

theLoop: for (;;) {
  if (a) {
    break theLoop;
  }
}

==>

LabeledStatement(Label, ForStatement(Keyword, Block(IfStatement(Keyword, Variable, Block(BreakStatement(Keyword, Label))))))

# Classes

class Foo {
  static one(a) { return a; };
  two(b) { return b; }
  finally() {}
}

class Foo extends require('another-class') {
  constructor() { super(); }
  bar() { super.a(); }
}

==>

ClassDeclaration(Keyword, Definition, ClassBody(
  MethodDefinition(Keyword, PropertyName, ParamList(Definition), Block(ReturnStatement(Keyword, Variable))),
  MethodDefinition(PropertyName, ParamList(Definition), Block(ReturnStatement(Keyword, Variable))),
  MethodDefinition(PropertyName, ParamList, Block))),

ClassDeclaration(Keyword, Definition, Keyword, CallExpression(Variable, ArgList(String)), ClassBody(
  MethodDefinition(PropertyName, ParamList, Block(CallExpression(Super, ArgList))),
  MethodDefinition(PropertyName, ParamList, Block(CallExpression(MemberExpression(Super, PropertyName), ArgList)))))

# Imports

import defaultMember from "module-name";
import * as name from "module-name";
import { member } from "module-name";
import { member1, member2 as alias2 } from "module-name";
import defaultMember, { member1, member2 as alias2, } from "module-name";
import "module-name";

==>

ImportDeclaration(Keyword, Definition, Keyword, String),
ImportDeclaration(Keyword, Star, Keyword, Definition, Keyword, String),
ImportDeclaration(Keyword, ImportGroup(Definition), Keyword, String),
ImportDeclaration(Keyword, ImportGroup(Definition, Variable, Keyword, Definition), Keyword, String),
ImportDeclaration(Keyword, Definition, ImportGroup(Definition, Variable, Keyword, Definition), Keyword, String),
ImportDeclaration(Keyword, String)

# Exports

export { name1, name2, name3 as x, nameN };
export let a, b = 2;
export default 2 + 2;
export default function() { }
export default async function name1() { }
export { name1 as default, } from "foo";
export * from 'foo';

==>

ExportDeclaration(Keyword, ExportGroup(Variable, Variable, Variable, Keyword, Variable, Variable)),
ExportDeclaration(Keyword, VariableDeclaration(Keyword, Definition, Definition, Operator, Number)),
ExportDeclaration(Keyword, Keyword, BinaryExpression(Number, Operator, Number)),
ExportDeclaration(Keyword, Keyword, FunctionDeclaration(Keyword, ParamList, Block)),
ExportDeclaration(Keyword, Keyword, FunctionDeclaration(Keyword, Keyword, Definition, ParamList, Block)),
ExportDeclaration(Keyword, ExportGroup(Variable, Keyword, Variable), Keyword, String),
ExportDeclaration(Keyword, Star, Keyword, String)

# Empty statements

if (true) { ; };;;

==>

IfStatement(Keyword, Boolean, Block)

# Comments

/* a */
one;

/* b **/
two;

/* c ***/
three;

/* d

***/
four;

y // comment
  * z;

==>

Comment,
Variable,
Comment,
Variable,
Comment,
Variable,
Comment,
Variable,
BinaryExpression(Variable(Comment), Operator, Variable)
