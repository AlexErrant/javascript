# Variable declaration

var a = b
  , c = d;
const [x] = y = 3;

==>

variable.d(var.k, definition.v, operator.n, variable.n, definition.v, operator.n, variable.n),
variable.d(const.k, array.p(definition.v), operator.n, assignment.e(variable.n, operator.n, number.l))

# Function declaration

function a(a, b) { return 3; }
function b({b}, c = d, e = f) {}

==>

function.d(function.k, definition.v, parameter.l(definition.v, definition.v), block.s(return.s(return.k, number.l))),
function.d(function.k, definition.v, parameter.l(
  object.p(property.d(property.n)),
  definition.v, operator.n, variable.n,
  definition.v, operator.n, variable.n), block.s)

# Async functions

async function foo() {}

class Foo { async bar() {} }

async (a) => { return foo; };

==>

function.d(async.k, function.k, definition.v, parameter.l, block.s),
class.d(class.k, definition.v, class.b(method.p(async.k, definition.property.n, parameter.l, block.s))),
expression.s(arrow.f(async.k, parameter.l(definition.v), block.s(return.s(return.k, variable.n))))

# If statements

if (x) log(y);

if (a.b) {
  d;
}

if (a) {
  c;
  d;
} else {
  e;
}

if (1) if (2) b; else c;

==>

if.c(if.k, parenthesized.e(variable.n), expression.s(call.e(variable.n, argument.l(variable.n)))),

if.c(if.k, parenthesized.e(member.e(variable.n, property.n)), block.s(expression.s(variable.n))),

if.c(if.k, parenthesized.e(variable.n),
  block.s(expression.s(variable.n), expression.s(variable.n)), else.k, block.s(expression.s(variable.n))),

if.c(if.k, parenthesized.e(number.l),
  if.c(if.k, parenthesized.e(number.l), expression.s(variable.n), else.k, expression.s(variable.n)))

# While loop

while (1) debugger;
while (2) {
  a;
  b;
}

==>

while.l(while.k, parenthesized.e(number.l), debugger.s(debugger.k)),
while.l(while.k, parenthesized.e(number.l), block.s(expression.s(variable.n), expression.s(variable.n)))

# Labels

foo: 1;
foo: while(2) break foo;

==>

labeled.s(label.n, expression.s(number.l)),
labeled.s(label.n, while.l(while.k, parenthesized.e(number.l), break.s(break.k, label.n)))

# Try

try { throw new Error; } catch {}
try { 1; } catch (x) { 2; } finally { 3; }

==>

try.s(try.k, block.s(throw.s(throw.k, new.e(new.k, variable.n))), catch.k, block.s),
try.s(try.k,
  block.s(expression.s(number.l)),
  catch.k, definition.v,
  block.s(expression.s(number.l)),
  finally.k,
  block.s(expression.s(number.l)))

# Switch

switch (x) {
  case 1:
    return true;
  case 2:
  case 50 * 3:
    console.log("ok");
  default:
    return false;
}

==>

switch.s(
  switch.k,
  parenthesized.e(variable.n),
  block.s(
    case.l(case.k, number.l),
    return.s(return.k, boolean.l),
    case.l(case.k, number.l),
    case.l(case.k, binary.o(number.l, operator.n, number.l)),
    expression.s(call.e(member.e(variable.n, property.n), argument.l(string.l))),
    default.l(default.k),
    return.s(return.k, boolean.l)))

# For

for (let x = 1; x < 10; x++) {}
for (const y of z) {}
for (var m in n) {}
for (q in r) {}
for (var a, b; c; d) continue;
for (i = 0, init(); i < 10; i++) {}
for (;;) {}
for (const {thing} in things) thing;
for await (let x of stream) {}

==>

for.l(for.k,
  for.s(variable.d(let.k, definition.v, operator.n, number.l),
    binary.o(variable.n, operator.n, number.l),
    unary.p(variable.n, operator.n)),
  block.s),
for.l(for.k, of.for.s(const.k, definition.v, of.k, variable.n), block.s),
for.l(for.k, in.for.s(var.k, definition.v, in.o, variable.n), block.s),
for.l(for.k, in.for.s(variable.n, in.o, variable.n), block.s),
for.l(for.k, for.s(variable.d(var.k, definition.v, definition.v), variable.n, variable.n), continue.s(continue.k)),
for.l(for.k, for.s(sequence.e(assignment.e(variable.n, operator.n, number.l), call.e(variable.n, argument.l)),
             binary.o(variable.n, operator.n, number.l), unary.p(variable.n, operator.n)), block.s),
for.l(for.k, for.s, block.s),
for.l(for.k, in.for.s(const.k, object.p(property.d(property.n)), in.o, variable.n), expression.s(variable.n)),
for.l(for.k, await.k, of.for.s(let.k, definition.v, of.k, variable.n), block.s)

# Labeled statements

theLoop: for (;;) {
  if (a) {
    break theLoop;
  }
}

==>

labeled.s(label.n, for.l(for.k, for.s,
  block.s(if.c(if.k, parenthesized.e(variable.n), block.s(break.s(break.k, label.n))))))

# Classes

class Foo {
  static one(a) { return a; };
  two(b) { return b; }
  finally() {}
}

class Foo extends require('another-class') {
  constructor() { super(); }
  bar() { super.a(); }
}

==>

class.d(class.k, definition.v, class.b(
  method.p(static.k, definition.property.n, parameter.l(definition.v), block.s(return.s(return.k, variable.n))),
  method.p(definition.property.n, parameter.l(definition.v), block.s(return.s(return.k, variable.n))),
  method.p(definition.property.n, parameter.l, block.s))),

class.d(class.k, definition.v, extends.k, call.e(variable.n, argument.l(string.l)), class.b(
  method.p(definition.property.n, parameter.l, block.s(expression.s(call.e(super.k, argument.l)))),
  method.p(definition.property.n, parameter.l, block.s(expression.s(call.e(member.e(super.k, property.n), argument.l))))))

# Imports

import defaultMember from "module-name";
import * as name from "module-name";
import { member } from "module-name";
import { member1, member2 as alias2 } from "module-name";
import defaultMember, { member1, member2 as alias2, } from "module-name";
import "module-name";

==>

import.d(import.k, definition.v, from.k, string.l),
import.d(import.k, star.p, as.k, definition.v, from.k, string.l),
import.d(import.k, import.g(definition.v), from.k, string.l),
import.d(import.k, import.g(definition.v, variable.n, as.k, definition.v), from.k, string.l),
import.d(import.k, definition.v, import.g(definition.v, variable.n, as.k, definition.v), from.k, string.l),
import.d(import.k, string.l)

# Exports

export { name1, name2, name3 as x, nameN };
export let a, b = 2;
export default 2 + 2;
export default function() { }
export default async function name1() { }
export { name1 as default, } from "foo";
export * from 'foo';

==>

export.d(export.k, export.g(variable.n, variable.n, variable.n, as.k, variable.n, variable.n)),
export.d(export.k, variable.d(let.k, definition.v, definition.v, operator.n, number.l)),
export.d(export.k, default.k, binary.o(number.l, operator.n, number.l)),
export.d(export.k, default.k, function.d(function.k, parameter.l, block.s)),
export.d(export.k, default.k, function.d(async.k, function.k, definition.v, parameter.l, block.s)),
export.d(export.k, export.g(variable.n, as.k, variable.n), from.k, string.l),
export.d(export.k, star.p, from.k, string.l)

# Empty statements

if (true) { ; };;;

==>

if.c(if.k, parenthesized.e(boolean.l), block.s)

# Comments

/* a */
one;

/* b **/
two;

/* c ***/
three;

/* d

***/
four;

y // comment
  * z;

==>

block.c,
expression.s(variable.n),
block.c,
expression.s(variable.n),
block.c,
expression.s(variable.n),
block.c,
expression.s(variable.n),
expression.s(binary.o(variable.n, line.c, operator.n, variable.n))
