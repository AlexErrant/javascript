# Type declaration {"dialect": "ts"}

function foo(a: number, b: "literal" | Map<number, boolean>): RegExp[] {}

==>

Script(FunctionDeclaration(function, VariableDefinition, ParamList(
  VariableDefinition, TypeDeclaration(TypeName),
  VariableDefinition, TypeDeclaration(UnionType(String, LogicOp, ParameterizedType(TypeName, TypeArgList(TypeName, TypeName))))
), TypeDeclaration(ArrayType(TypeName)), Block))

# Type predicate {"dialect": "ts"}

function isFoo(foo: any): foo is Foo { return true }

==>

Script(FunctionDeclaration(function, VariableDefinition, ParamList(
  VariableDefinition, TypeDeclaration(TypeName)
), TypePredicate(VariableName, is, TypeName), Block(ReturnStatement(return, BooleanLiteral))))

# Type alias {"dialect": "ts"}

type Foo<T extends string> = T[]

==>

Script(TypeAliasDeclaration(type, TypeDefinition, TypeParamList(TypeDefinition, extends, TypeName), Equals, ArrayType(TypeName)))

# Enum declaration {"dialect": "ts"}

const enum Type { Red = 1, Blue, Green }

==>

Script(EnumDeclaration(const, enum, TypeDefinition, EnumBody(PropertyName, Equals, Number, PropertyName, PropertyName)))

# Interface declaration {"dialect": "ts"}

interface Foo {
  readonly a: number
  b(arg: string): void
  (call: number): boolean
  new (): Foo
  readonly [x: string]: number
}

==>

Script(InterfaceDeclaration(interface, TypeDefinition, ObjectType(
  PropertyType(readonly, PropertyNameDefinition, TypeDeclaration(TypeName)),
  MethodType(PropertyNameDefinition, ParamList(VariableDefinition, TypeDeclaration(TypeName)), TypeDeclaration(void)),
  CallSignature(ParamList(VariableDefinition, TypeDeclaration(TypeName)), TypeDeclaration(TypeName)),
  NewSignature(new,ParamList, TypeDeclaration(TypeName)),
  IndexSignature(readonly, PropertyNameDefinition, TypeDeclaration(TypeName), TypeDeclaration(TypeName)))))

# Call type args {"dialect": "ts"}

foo<number, string>() + new Bar<11>()
x < 10 > 5

==>

Script(
  ExpressionStatement(BinaryExpression(
    CallExpression(VariableName, TypeArgList(TypeName, TypeName), ArgList),
    ArithOp,
    NewExpression(new, VariableName, TypeArgList(Number), ArgList))),
  ExpressionStatement(BinaryExpression(BinaryExpression(VariableName, CompareOp, Number), CompareOp, Number)))

# Advanced types {"dialect": "ts"}

let x: typeof X.x | keyof Y & Z["Foo"] | A<string>
let tuple: [a, b]
let f: (x: number) => boolean

==>

Script(
  VariableDeclaration(let, VariableDefinition, TypeDeclaration(
    UnionType(UnionType(TypeofType(typeof, MemberExpression(VariableName, PropertyName)), LogicOp,
                        IntersectionType(KeyofType(keyof, TypeName), LogicOp, IndexedType(TypeName, String))),
              LogicOp, ParameterizedType(TypeName, TypeArgList(TypeName))))),
  VariableDeclaration(let, VariableDefinition, TypeDeclaration(TupleType(TypeName, TypeName))),
  VariableDeclaration(let, VariableDefinition, TypeDeclaration(FunctionSignature(
    ParamList(VariableDefinition, TypeDeclaration(TypeName)), Arrow, TypeName))))

# Prefix cast {"dialect": "ts"}

<string>foo

==>

Script(ExpressionStatement(PrefixCast(TypeName, VariableName)))

# No prefix cast in JSX {"dialect": "ts jsx"}

<string>foo</string>

==>

Script(ExpressionStatement(JSXElement(
  JSXOpenTag(JSXStartTag, JSXIdentifier, JSXEndTag),
  JSXText,
  JSXCloseTag(JSXStartCloseTag, JSXIdentifier, JSXEndTag))))

# Class definition {"dialect": "ts"}

class Foo<T> extends Bar<T> implements Stuff {
  a: number
  public readonly b: string = "two"
  constructor(readonly x: boolean, public y: number, z: string) {}
  private static blah(): void {}
}

==>

Script(ClassDeclaration(
  class, VariableDefinition, TypeParamList(TypeDefinition),
  extends ParameterizedType(TypeName, TypeArgList(TypeName)),
  implements TypeName,
  ClassBody(
    PropertyDeclaration(PropertyNameDefinition, TypeDeclaration(TypeName)),
    PropertyDeclaration(Privacy, readonly, PropertyNameDefinition, TypeDeclaration(TypeName), Equals, String),
    MethodDeclaration(PropertyNameDefinition, ParamList(
      readonly, VariableDefinition, TypeDeclaration(TypeName),
      Privacy, VariableDefinition, TypeDeclaration(TypeName),
      VariableDefinition, TypeDeclaration(TypeName)), Block),
    MethodDeclaration(Privacy, static, PropertyNameDefinition, ParamList, TypeDeclaration(void), Block))))
