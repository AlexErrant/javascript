# Minimal

0

==> script.document.lang=javascript(expression.s(number.l))

# Strings

"A string with \"double\" and 'single' quotes";
'A string with "double" and \'single\' quotes';
'\\';
"\\";

'A string with new \
line';

==>

expression.s(string.l), expression.s(string.l), expression.s(string.l),
expression.s(string.l), expression.s(string.l)

# Numbers

101;
3.14;
3.14e+1;
0x1ABCDEFabcdef;
0o7632157312;
0b1010101001;
1e+3;

==>

expression.s(number.l), expression.s(number.l), expression.s(number.l), expression.s(number.l),
expression.s(number.l), expression.s(number.l), expression.s(number.l)

# Identifiers

theVar;
theVar2;
$_;
é象𫝄;
últimaVez;
県;

==>

expression.s(variable.n), expression.s(variable.n), expression.s(variable.n),
expression.s(variable.n), expression.s(variable.n), expression.s(variable.n)

# RegExps

/one\\/;
/one/g;
/one/i;
/one/gim;
/on\/e/gim;
/on[^/]afe/gim;
/[\]/]/;

==>

expression.s(regexp.l), expression.s(regexp.l), expression.s(regexp.l), expression.s(regexp.l),
expression.s(regexp.l), expression.s(regexp.l), expression.s(regexp.l)

# Arrays

[];
[ "item1" ];
[ "item1", ];
[ "item1", item2 ];
[ , item2 ];
[ item2 = 5 ];

==>

expression.s(array.e),
expression.s(array.e(string.l)),
expression.s(array.e(string.l)),
expression.s(array.e(string.l, variable.n)),
expression.s(array.e(variable.n)),
expression.s(array.e(assignment.e(variable.n, operator.n, number.l)))

# Functions

[
  function() {},
  function(arg1, ...arg2) {
    arg2;
  },
  function stuff() {},
  function trailing(a,) {},
  function trailing(a,b,) {}
]

==>

expression.s(array.e(
  function.e(function.k, parameter.l, block.s),
  function.e(function.k, parameter.l(definition.v, definition.v), block.s(expression.s(variable.n))),
  function.e(function.k, definition.v, parameter.l, block.s),
  function.e(function.k, definition.v, parameter.l(definition.v), block.s),
  function.e(function.k, definition.v, parameter.l(definition.v, definition.v), block.s)))

# Arrow functions

a => 1;
() => 2;
(d, e) => 3;
(f, g,) => {
  return h;
};
async () => 4;

==>

expression.s(arrow.f(parameter.l(definition.v), number.l)),
expression.s(arrow.f(parameter.l, number.l)),
expression.s(arrow.f(parameter.l(definition.v, definition.v), number.l)),
expression.s(arrow.f(parameter.l(definition.v, definition.v), block.s(return.s(return.k, variable.n)))),
expression.s(arrow.f(async.k, parameter.l, number.l))

# Long potential arrow function

(assign = [to, from], from = assign[0], to = assign[1]);

==>

expression.s(parenthesized.e(
  sequence.e(
    assignment.e(variable.n, operator.n, array.e(variable.n, variable.n)),
    assignment.e(variable.n, operator.n, member.e(variable.n, number.l)),
    assignment.e(variable.n, operator.n, member.e(variable.n, number.l)))))

# Ternary operator

condition ? case1 : case2;

x.y = some.condition ? 2**x : 1 - 2;

==>

expression.s(conditional.o(variable.n, operator.n, variable.n, operator.n, variable.n)),

expression.s(assignment.e(
  member.e(variable.n, property.n), operator.n,
  conditional.o(member.e(variable.n, property.n),
    operator.n, binary.o(number.l, operator.n, variable.n),
    operator.n, binary.o(number.l, operator.n, number.l))))

# Type operators

typeof x;
x instanceof String;

==>

expression.s(unary.p(typeof.o, variable.n)),
expression.s(binary.o(variable.n, instanceof.o, variable.n))

# Delete

delete thing['prop'];
true ? delete thing.prop : null;

==>

expression.s(unary.p(delete.o, member.e(variable.n, string.l))),
expression.s(conditional.o(boolean.l, operator.n,
  unary.p(delete.o, member.e(variable.n, property.n)), operator.n, null.k))

# Void

a = void b();

==>

expression.s(assignment.e(variable.n, operator.n, unary.p(void.o, call.e(variable.n, argument.l))))

# Augmented assignment

s |= 1;
t %= 2;
w ^= 3;
x += 4;
y.z *= 5;
z += 1;
a >>= 1;
b >>>= 1;
c <<= 1;

==>

expression.s(assignment.e(variable.n, operator.n, number.l)),
expression.s(assignment.e(variable.n, operator.n, number.l)),
expression.s(assignment.e(variable.n, operator.n, number.l)),
expression.s(assignment.e(variable.n, operator.n, number.l)),
expression.s(assignment.e(member.e(variable.n, property.n), operator.n, number.l)),
expression.s(assignment.e(variable.n, operator.n, number.l)),
expression.s(assignment.e(variable.n, operator.n, number.l)),
expression.s(assignment.e(variable.n, operator.n, number.l)),
expression.s(assignment.e(variable.n, operator.n, number.l))

# Operator precedence

a <= b && c >= d;
a.b = c ? d : e;
a && b(c) && d;
a && new b(c) && d;
typeof a == b && c instanceof d;

==>

expression.s(binary.o(binary.o(variable.n, operator.n, variable.n), operator.n, binary.o(variable.n, operator.n, variable.n))),
expression.s(assignment.e(member.e(variable.n, property.n), operator.n,
  conditional.o(variable.n, operator.n, variable.n, operator.n, variable.n))),
expression.s(binary.o(binary.o(variable.n, operator.n, call.e(variable.n, argument.l(variable.n))), operator.n, variable.n)),
expression.s(binary.o(binary.o(variable.n, operator.n, new.e(new.k, variable.n, argument.l(variable.n))), operator.n, variable.n)),
expression.s(binary.o(binary.o(unary.p(typeof.o, variable.n), operator.n, variable.n), operator.n,
  binary.o(variable.n, instanceof.o, variable.n)))

# Rest args

foo(...rest);

==>

expression.s(call.e(variable.n, argument.l(variable.n)))

# Forward slashes after parenthesized expressions

(foo - bar) / baz;
if (foo - bar) /baz/;
(this.a() / this.b() - 1) / 2;

==>

expression.s(binary.o(parenthesized.e(binary.o(variable.n, operator.n, variable.n)), operator.n, variable.n)),
if.c(if.k, parenthesized.e(binary.o(variable.n, operator.n, variable.n)), expression.s(regexp.l)),
expression.s(binary.o(
  parenthesized.e(
    binary.o(binary.o(call.e(member.e(this.k, property.n), argument.l), operator.n,
                                      call.e(member.e(this.k, property.n), argument.l)),
                     operator.n, number.l)),
  operator.n, number.l))

# Yield expressions

yield db.users.where('[endpoint+email]');

==>

expression.s(unary.p(yield.k,
  call.e(member.e(member.e(variable.n, property.n), property.n), argument.l(string.l))))

# Template strings

`one line`;
`multi
  line`;

`multi
  ${2 + 2}
  hello
  ${1, 2}
  line`;

`$$$$`;
`$`;
`$$$$${ async }`;

`\\`;

`one${`two${`three`}`}`;

f`hi${there}`;

==>

expression.s(template.s(template.string.c, template.string.c, template.string.c)),
expression.s(template.s(template.string.c, template.string.c, template.string.c)),
expression.s(template.s(template.string.c, template.string.c, binary.o(number.l, operator.n, number.l),
  template.string.c, sequence.e(number.l, number.l), template.string.c, template.string.c)),
expression.s(template.s(template.string.c, template.string.c, template.string.c)),
expression.s(template.s(template.string.c, template.string.c, template.string.c)),
expression.s(template.s(template.string.c, template.string.c, variable.n, template.string.c)),
expression.s(template.s(template.string.c, template.string.c, template.string.c)),
expression.s(template.s(template.string.c, template.string.c,
  template.s(template.string.c, template.string.c, template.s(template.string.c, template.string.c, template.string.c),
     template.string.c), template.string.c)),
expression.s(tagged.t(variable.n, template.s(template.string.c, template.string.c, variable.n, template.string.c)))

# Atoms

this;
null;
undefined;
true;
false;

==> expression.s(this.k), expression.s(null.k), expression.s(variable.n), expression.s(boolean.l), expression.s(boolean.l)

# Objects

foo({},
    { a: "b" },
    { c: "d", "e": f, 1: 2 },
    {
      g,
      [methodName]() {}
    },
    {b, get},
    {a,});

==>

expression.s(call.e(variable.n, argument.l(
  object.e,
  object.e(property.d(definition.p, string.l)),
  object.e(property.d(definition.p, string.l), property.d(string.l, variable.n), property.d(number.l, number.l)),
  object.e(property.d(definition.p), property.d(variable.n, parameter.l, block.s)),
  object.e(property.d(definition.p), property.d(definition.p)),
  object.e(property.d(definition.p)))))

# Method definitions

({
  foo: true,

  add(a, b) {
    return a + b;
  },

  get bar() { return c; },

  set bar(a) { c = a; },

  *barGenerator() { yield c; },

  get() { return 1; }
});

==>

expression.s(parenthesized.e(
  object.e(
    property.d(definition.property.n, boolean.l),
    property.d(definition.property.n, parameter.l(definition.v, definition.v), block.s(return.s(return.k, binary.o(variable.n, operator.n, variable.n)))),
    property.d(get.k, definition.property.n, parameter.l, block.s(return.s(return.k, variable.n))),
    property.d(set.k, definition.property.n, parameter.l(definition.v), block.s(expression.s(assignment.e(variable.n, operator.n, variable.n)))),
    property.d(star.p, definition.property.n, parameter.l, block.s(expression.s(unary.p(yield.k, variable.n)))),
    property.d(definition.property.n, parameter.l, block.s(return.s(return.k, number.l))))))

# Keyword property names

({
  finally() {},
  catch() {},
  get: function () {},
  set() {},
  static: true,
  async: true,
});

==>

expression.s(parenthesized.e(object.e(
  property.d(definition.property.n, parameter.l, block.s),
  property.d(definition.property.n, parameter.l, block.s),
  property.d(definition.property.n, function.e(function.k, parameter.l, block.s)),
  property.d(definition.property.n, parameter.l, block.s),
  property.d(definition.property.n, boolean.l),
  property.d(definition.property.n, boolean.l))))

# Generator functions

[
  function *() {},
  function *generateStuff(arg1, arg2) {
    yield;
    yield arg2;
  }
];

==>

expression.s(array.e(
  function.e(function.k, star.p, parameter.l, block.s),
  function.e(function.k, star.p, definition.v, parameter.l(definition.v, definition.v), block.s(
    expression.s(variable.n),
    expression.s(unary.p(yield.k, variable.n))))))

# Member expressions

x.someProperty;
x[someVariable];
f()["some-string"];
return returned.promise().done(a).fail(b);

==>

expression.s(member.e(variable.n, property.n)),
expression.s(member.e(variable.n, variable.n)),
expression.s(member.e(call.e(variable.n, argument.l), string.l)),

return.s(return.k, call.e(
  member.e(call.e(
    member.e(call.e(
      member.e(variable.n, property.n), argument.l), property.n), argument.l(variable.n)), property.n), argument.l(variable.n)))

# Callback chain

return this.map(function (a) {
  return a.b;
})

// a comment

.filter(function (c) {
  return 2;
});

==>

return.s(return.k, call.e(
  member.e(call.e(
    member.e(this.k, property.n), argument.l(function.e(function.k, parameter.l(definition.v), block.s(
      return.s(return.k, member.e(variable.n, property.n)))))),
    line.c,
    property.n),
  argument.l(function.e(function.k, parameter.l(definition.v), block.s(return.s(return.k, number.l))))))

# Function calls

x.someMethod(arg1, "arg2");
(function(x, y) {

}(a, b));
f(new foo.bar(1), 2);

==> 

expression.s(call.e(member.e(variable.n, property.n), argument.l(variable.n, string.l))),
expression.s(parenthesized.e(call.e(function.e(function.k, parameter.l(definition.v, definition.v), block.s),
  argument.l(variable.n, variable.n)))),
expression.s(call.e(variable.n, argument.l(new.e(new.k, member.e(variable.n, property.n), argument.l(number.l)), number.l)))

# Constructor calls

new foo(1);
new module.Klass(1, "two");
new Thing;

==>

expression.s(new.e(new.k, variable.n, argument.l(number.l))),
expression.s(new.e(new.k, member.e(variable.n, property.n), argument.l(number.l, string.l))),
expression.s(new.e(new.k, variable.n))

# Await Expressions

await asyncFunction();
await asyncPromise;

==>

expression.s(unary.p(await.k, call.e(variable.n, argument.l))),
expression.s(unary.p(await.k, variable.n))

# Numeric operators

i++;
i--;
i + j * 3 - j % 5;
2 ** i * 3;
2 * i ** 3;
+x;
-x;

==>

expression.s(unary.p(variable.n, operator.n)),
expression.s(unary.p(variable.n, operator.n)),
expression.s(binary.o(
  binary.o(variable.n, operator.n, binary.o(variable.n, operator.n, number.l)),
  operator.n,
  binary.o(variable.n, operator.n, number.l))),
expression.s(binary.o(binary.o(number.l, operator.n, variable.n), operator.n, number.l)),
expression.s(binary.o(number.l, operator.n, binary.o(variable.n, operator.n, number.l))),
expression.s(unary.p(operator.n, variable.n)),
expression.s(unary.p(operator.n, variable.n))

# Boolean operators

i || j;
i && j;
!a && !b || !c && !d;

==>

expression.s(binary.o(variable.n, operator.n, variable.n)),
expression.s(binary.o(variable.n, operator.n, variable.n)),
expression.s(binary.o(
  binary.o(unary.p(operator.n, variable.n), operator.n, unary.p(operator.n, variable.n)),
  operator.n,
  binary.o(unary.p(operator.n, variable.n), operator.n, unary.p(operator.n, variable.n))))

# Bitwise operators

i >> j;
i >>> j;
i << j;
i & j;
i | j;
~i ^ ~j;

==>

expression.s(binary.o(variable.n, operator.n, variable.n)),
expression.s(binary.o(variable.n, operator.n, variable.n)),
expression.s(binary.o(variable.n, operator.n, variable.n)),
expression.s(binary.o(variable.n, operator.n, variable.n)),
expression.s(binary.o(variable.n, operator.n, variable.n)),
expression.s(binary.o(unary.p(operator.n, variable.n), operator.n, unary.p(operator.n, variable.n)))

# Relational operators

x < y;
x <= y;
x == y;
x === y;
x != y;
x !== y;
x > y;
x >= y;

==>

expression.s(binary.o(variable.n, operator.n, variable.n)),
expression.s(binary.o(variable.n, operator.n, variable.n)),
expression.s(binary.o(variable.n, operator.n, variable.n)),
expression.s(binary.o(variable.n, operator.n, variable.n)),
expression.s(binary.o(variable.n, operator.n, variable.n)),
expression.s(binary.o(variable.n, operator.n, variable.n)),
expression.s(binary.o(variable.n, operator.n, variable.n)),
expression.s(binary.o(variable.n, operator.n, variable.n))

# Word operators

x in y;
x instanceof y;
!x instanceof y;

==>

expression.s(binary.o(variable.n, in.o, variable.n)),
expression.s(binary.o(variable.n, instanceof.o, variable.n)),
expression.s(binary.o(unary.p(operator.n, variable.n), instanceof.o, variable.n))

# Assignments

x = 0;
x.y = 0;
x["y"] = 0;
async = 0;
[a, b = 2] = foo;
({a, b, ...d} = c);

==>

expression.s(assignment.e(variable.n, operator.n, number.l)),
expression.s(assignment.e(member.e(variable.n, property.n), operator.n, number.l)),
expression.s(assignment.e(member.e(variable.n, string.l), operator.n, number.l)),
expression.s(assignment.e(variable.n, operator.n, number.l)),
expression.s(assignment.e(array.p(definition.v, definition.v, operator.n, number.l), operator.n, variable.n)),
expression.s(parenthesized.e(
  assignment.e(object.p(property.d(property.n), property.d(property.n), property.d(definition.v)), operator.n, variable.n)))

# Comma operator

a = 1, b = 2;
c = {d: (3, 4 + 5)};

==>

expression.s(sequence.e(assignment.e(variable.n, operator.n, number.l), assignment.e(variable.n, operator.n, number.l))),
expression.s(assignment.e(variable.n, operator.n, object.e(
  property.d(definition.property.n, parenthesized.e(sequence.e(number.l, binary.o(number.l, operator.n, number.l)))))))

# Punctuation

(foo(1, 2), bar);

==>

expression.s(parenthesized.e(open.paren.p,
  sequence.e(call.e(variable.n, argument.l(open.paren.p, number.l, comma.p, number.l, close.paren.p)), comma.p,
  variable.n), close.paren.p), semicolon.p)

# Doesn't choke on unfinished ternary operator

1?1

==> expression.s(conditional.o(number.l, operator.n, number.l, error))
