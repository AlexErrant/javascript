precedence {
  else left,
  member,
  newArgs,
  call,
  taggedTemplate,
  prefix,
  suffix,
  typeof,
  exp left,
  times left,
  plus left,
  shift left,
  loop,
  rel left,
  equal left,
  bitOr left,
  bitXor left,
  bitAnd left,
  and left,
  or left,
  ternary left,
  assign left,
  comma left,
  statement cut
}

program { statement+ }

statement {
  ExportDeclaration |
  ImportDeclaration |
  tag.ForStatement<kw<"for"> ckw<"await">? "(" forSpec ")" statement> |
  tag.WhileStatement<kw<"while"> parenExpression statement> |
  tag.WithStatement<kw<"with"> parenExpression statement> |
  tag.DoWhileStatement<kw<"do"> statement kw<"while"> parenExpression semi> |
  tag.IfStatement<kw<"if"> parenExpression statement (!else kw<"else"> statement)?> |
  tag.SwitchStatement<kw<"switch"> parenExpression tag.Block<"{" switchItem* "}">> |
  tag.TryStatement<kw<"try"> Block (kw<"catch"> ("(" pattern ")")? Block)? (kw<"finally"> Block)?> |
  tag.ReturnStatement<kw<"return"> expression semi> |
  tag.ThrowStatement<kw<"throw"> expression semi> |
  tag.BreakStatement<kw<"break"> Label? semi> |
  tag.ContinueStatement<kw<"continue"> Label? semi> |
  tag.DebuggerStatement<kw<"debugger"> semi> |
  Block |
  LabeledStatement |
  declaration |
  expression semi |
  ";"
}

ExportDeclaration {
  kw<"export"> Star kw<"from"> String semi |
  kw<"export"> kw<"default"> (FunctionDeclaration | ClassDeclaration | expression semi) |
  kw<"export"> declaration |
  kw<"export"> ExportGroup (kw<"from"> String)? semi
}

ExportGroup {
  "{" commaSep<Variable (kw<"as"> Variable)?> "}"
}

ImportDeclaration {
  kw<"import"> (Star kw<"as"> Definition | commaSep<Definition | ImportGroup>) kw<"from"> String semi |
  kw<"import"> String semi
}

ImportGroup {
  "{" commaSep<Definition | Variable kw<"as"> Definition> "}"
}

LabeledStatement {
  Label ":" statement
}

forSpec {
  (VariableDeclaration | expression ";") expression? ";" expression? |
  tag.LoopDeclaration<
    ((kw<"let"> | kw<"var"> | kw<"const">) pattern | Variable | MemberExpression | ArrayPattern | ObjectPattern)
    !loop (kw<"in"> | kw<"of">) expression
  > |
  ";" expression? ";" expression?
}

declaration {
  FunctionDeclaration | ClassDeclaration | VariableDeclaration
}

FunctionDeclaration {
  ckw<"async">? !statement kw<"function"> Star? Definition? ParamList Block
}

ClassDeclaration {
  !statement kw<"class"> Definition (kw<"extends"> expression)? ClassBody
}

ClassBody {
  "{" (MethodDefinition | ";")* "}"
}

MethodDefinition {
  kw<"static">?
  ckw<"async">?
  (ckw<"get"> | ckw<"set"> | Star)?
  PropertyName
  ParamList
  Block
}

VariableDeclaration {
  (kw<"let"> | kw<"var"> | kw<"const">) commaSep1<patternAssign> semi
}

pattern { Definition | ArrayPattern | ObjectPattern }

ArrayPattern { "[" commaSep<"..." patternAssign | patternAssign> ~destructure "]" }

ObjectPattern { "{" commaSep<patternProperty> ~destructure "}" }

patternAssign {
  pattern (op<"="> expressionNoComma)?
}

ParamList {
  "(" commaSep<"..." patternAssign | patternAssign> ")"
}

parenExpression {
  "(" expression ")"
}

Block {
  !statement "{" statement* "}"
}

switchItem {
  tag.SwitchCase<kw<"case"> expression ":"> |
  tag.SwitchDefault<kw<"default"> ":"> |
  statement
}

expression {
  expressionNoComma | SequenceExpression
}

SequenceExpression {
  expressionNoComma !comma "," expressionNoComma
}

expressionNoComma {
  Number |
  String |
  TemplateString |
  Variable |
  boolean |
  this |
  null |
  super |
  RegExp |
  ArrayExpression |
  tag.ObjectExpression<"{" commaSep<Property> ~destructure "}"> |
  NewExpression |
  PrefixExpression |
  "(" expression ")" |
  ClassExpression |
  FunctionExpression |
  ArrowFunction |
  MemberExpression |
  BinaryExpression |
  tag.ConditionalExpression<expressionNoComma !ternary op<"?"> expressionNoComma tag.Operator<":"> expressionNoComma> |
  AssignmentExpression |
  SuffixExpression |
  tag.CallExpression<expressionNoComma !call ArgList> |
  tag.TaggedTemplateExpression<expressionNoComma !taggedTemplate TemplateString>
}

ArrayExpression {
  "[" commaSep1<expressionNoComma | ""> ~destructure "]"
}

propName { PropertyName | "[" expression "]" | Number | String }

Property {
  ckw<"async">? (ckw<"get"> | ckw<"set"> | Star)? propName ParamList Block |
  propName ~destructure (":" expressionNoComma)? |
  "..." expressionNoComma
}

patternProperty=Property {
  "..." patternAssign |
  (PropertyName | Number | String) ~destructure (":" pattern)? (op<"="> expressionNoComma)?
}

ClassExpression {
  kw<"class"> Definition? (kw<"extends"> expression)? ClassBody
}

FunctionExpression {
  kw<"function"> Star? Definition? ParamList Block
}

NewExpression {
  kw<"new"> expressionNoComma (!newArgs ArgList)?
}

PrefixExpression {
  !prefix (ckw<"await"> | ckw<"yield"> | kw<"void"> | kw<"typeof"> | kw<"delete"> | op<"!"> | op<"~"> | op<"++" | "--"> | op<"+" | "-">)
  expressionNoComma
}

BinaryExpression {
  expressionNoComma !exp op<"**"> expressionNoComma |
  expressionNoComma !times (op<"/" | "%"> | tag.Operator<"*">) expressionNoComma |
  expressionNoComma !plus op<"+" | "-"> expressionNoComma |
  expressionNoComma !shift op<">>" ">"? | "<<"> expressionNoComma |
  expressionNoComma !rel (op<"<" "="? | ">" "="?> | kw<"in"> | kw<"instanceof">) expressionNoComma |
  expressionNoComma !equal op<"==" "="? | "!=" "="?> expressionNoComma |
  expressionNoComma !bitOr op<"|"> expressionNoComma |
  expressionNoComma !bitXor op<"^"> expressionNoComma |
  expressionNoComma !bitAnd op<"&"> expressionNoComma |
  expressionNoComma !and op<"&&"> expressionNoComma |
  expressionNoComma !or op<"||"> expressionNoComma
}

AssignmentExpression {
  (Variable | MemberExpression) !assign (op<([+\-/|&%^] | "*" "*"? | "<<" | ">>" ">"?) "=">) expressionNoComma |
  (Variable | MemberExpression | ArrayPattern | ObjectPattern) !assign op<"="> expressionNoComma
}

MemberExpression {
  expressionNoComma !member ("." PropertyName | "[" expression "]")
}

SuffixExpression {
  expressionNoComma !suffix op<"++" | "--">
}

ArgList {
  "(" commaSep<"..."? expressionNoComma> ")"
}

ArrowFunction {
  ckw<"async">? (tag.ParamList<Definition> | ParamList) "=>" (Block | expression)
}

TemplateString {
  Template | TemplateStart expression (TemplateContinue expression)* TemplateEnd
}

commaSep<content> {
  "" | content ("," content?)*
}

commaSep1<content> {
  content ("," content)*
}

kw<word> { specialize<identifier, word, Keyword> }

// Contextual keywords
ckw<word> { extend<identifier, word, Keyword> }

semi { ";" | insertSemi }

boolean { specialize<identifier, "true", Boolean> | specialize<identifier, "false", Boolean> }

this { specialize<identifier, "this", This> }

null { specialize<identifier, "null", Null> }

super { specialize<identifier, "super", Super> }

Star { "*" }

PropertyName { identifier }

Variable { identifier ~arrow }

Definition { identifier ~arrow }

Label { identifier }

tokens {
  skip { std.whitespace+ | LineComment | BlockComment }

  LineComment=Comment { "//" [^\n]* }

  BlockComment=Comment { "/*" blockCommentRest }

  blockCommentRest { [^*] blockCommentRest | "*" blockCommentAfterStar }

  blockCommentAfterStar { "/" | "*" blockCommentAfterStar | [^/*] blockCommentRest }

  identifierChar { std.asciiLetter | [_$\u{a1}-\u{10ffff}] }

  identifier { identifierChar (identifierChar | std.digit)* }

  Number {
    (std.digit+ ("." std.digit*)? | "." std.digit+) (("e" | "E") ("+" | "-")? std.digit+)? |
    "0x" (std.digit | [a-fA-F])+ |
    "0b" [01]+ |
    "0o" [0-7]+
  }

  String {
    '"' ([^\\\n"] | "\\" _)* '"'? |
    "'" ([^\\\n'] | "\\" _)* "'"?
  }

  // This is a rather cryptic kludge using recursion to be able to
  // match ${ as the end of TemplateStart (and not a valid subsequence in
  // Template) without getting confused by something like $${. It uses
  // recursion to switch between two matching modes, depending on
  // whether the last character was a $. Both modes are expressed by
  // `templateRest` (or `templateStartRest`) with different arguments.

  Template { "`" templateRest<[^$\\`]> }

  templateRest<exclude> {
    "`" |
    "$" templateRest<[^$\\`{]> |
    "\\" _ templateRest<[^$\\`]> |
    exclude templateRest<[^$\\`]>
  }

  TemplateStart=Template { "`" templateStartRest<[^$\\`]> }

  templateStartRest<exclude> {
    "$" ("{" | templateStartRest<[^`${\\]>) |
    "\\" _ templateStartRest<[^$\\`]> |
    exclude templateStartRest<[^$\\`]>
  }

  TemplateContinue=Template { "}" templateStartRest<[^$\\`]> }

  TemplateEnd=Template { "}" templateRest<[^$\\`]> }

  op<expr>=Operator { expr }

  group {
    RegExp { "/" ([^/\\\n[] | "\\" [^\n] | "[" ([^\n\\\]] | "\\" [^\n])* "]")+ ("/" [gimsuy]*)? }
  }

  external insertSemicolon from "./semicolon" !low { insertSemi }
}
