prec {
  statement,
  else left,
  member,
  prefix,
  newArgs,
  call,
  suffix,
  typeof,
  exp left,
  times left,
  plus left,
  compare left,
  and left,
  or left,
  ternary,
  assign left,
  comma left
}

program { statement+ }

statement {
  ExportStatement |
  ImportStatement |
  tag.ForStatement<kw<"for"> "(" forSpec ")" statement> |
  tag.WhileStatement<kw<"while"> parenExpression statement> |
  tag.DoWhileStatement<kw<"do"> statement kw<"while"> parenExpression semi> |
  tag.IfStatement<kw<"if"> parenExpression statement !else (kw<"else"> statement)?> |
  tag.SwitchStatement<kw<"switch"> parenExpression tag.Block<"{" switchItem* "}">> |
  tag.TryStatement<kw<"try"> Block (kw<"catch"> ("(" pattern ")")? Block)? (kw<"finally"> Block)?> |
  tag.ReturnStatement<kw<"return"> expression semi> |
  tag.ThrowStatement<kw<"throw"> expression semi> |
  tag.BreakStatement<kw<"break"> Label? semi> |
  tag.ContinueStatement<kw<"continue"> Label? semi> |
  tag.DebuggerStatement<kw<"debugger"> semi> |
  Block |
  LabeledStatement |
  declaration |
  expression semi |
  semi
}

ExportStatement {
  kw<"export"> plainStar kw<"from"> String semi |
  kw<"export"> kw<"default"> expression semi |
  kw<"export"> declaration semi |
  kw<"export"> ExportGroup (kw<"from"> String)? semi
}

ExportGroup {
  "{" (Variable (kw<"as"> Variable)?)* "}"
}

ImportStatement {
  kw<"import"> (plainStar kw<"as"> Definition | Definition | ImportGroup) kw<"from"> String semi
  kw<"import"> String semi
}

ImportGroup {
  "{" (Definition (kw<"as"> Definition)?)* "}"
}

LabeledStatement {
  Label ":" statement
}

forSpec {
  VariableDeclaration expression? ";" expression? |
  tag.LoopDeclaration<(kw<"let"> | kw<"var"> | kw<"const">) pattern (kw<"in"> | kw<"of">) expression> |
  ";" expression? ";" expression?
}

declaration {
  FunctionDeclaration | ClassDeclaration | VariableDeclaration
}

FunctionDeclaration {
  !statement kw<"function"> Definition plainStar? ParamList Block |
  kw<"async"> kw<"function"> Definition plainStar? ParamList Block
}

ClassDeclaration {
  !statement kw<"class"> Definition (kw<"extends"> expression)? ClassBody
}

ClassBody {
  "{" MethodDefinition* "}"
}

MethodDefinition {
  kw<"static">?
  kw<"async">?
  (kw<"get"> | kw<"set"> | plainStar)?
  PropertyDefinition
  ParamList
  Block
}

VariableDeclaration {
  (kw<"let"> | kw<"var"> | kw<"const">) commaSep1<patternAssign> semi
}

pattern {
  Definition | ArrayPattern | ObjectPattern
}

patternAssign {
  pattern (op<"="> expressionNoComma)?
}

ObjectPattern {
  "{" commaSep<"..."? Property (":" pattern)? (op<"="> expressionNoComma)?> "}"
}

ArrayPattern {
  "[" commaSep<"..." patternAssign | patternAssign> "]"
}

ParamList {
  "(" commaSep<"..." patternAssign | patternAssign> ")"
}

parenExpression {
  "(" expression ")"
}

Block {
  !statement "{" statement* "}"
}

switchItem {
  tag.SwitchCase<kw<"case"> expression ":"> |
  tag.SwitchDefault<kw<"default"> ":"> |
  statement
}

expression {
  expressionNoComma | SequenceExpression
}

SequenceExpression {
  expressionNoComma !comma "," expressionNoComma
}

expressionInner {
  Number |
  String |
  !ambig.arrow Variable |
  boolean |
  null |
  RegExp |
  ArrayExpression |
  NewExpression |
  PrefixExpression |
  !ambig.arrow "(" expression ")" |
  ClassExpression |
  FunctionExpression |
  !ambig.arrow ArrowFunction
}

expressionNoComma {
  expressionInner |
  MemberExpression<expressionNoComma> |
  BinaryExpression |
  AssignmentExpression |
  SuffixExpression |
  CallExpression 
}

ArrayExpression {
  "[" commaSep<expressionNoComma> "]"
}

ClassExpression {
  kw<"class"> (kw<"extends"> expression)? ClassBody |
  kw<"class"> Definition (kw<"extends"> expression)? ClassBody
}

FunctionExpression {
  kw<"function"> plainStar? ParamList Block |
  kw<"function"> Definition plainStar? ParamList Block
}

NewExpression {
  kw<"new"> (expressionInner | MemberExpression<expressionInner>) !newArgs ArgList |
  kw<"new"> (expressionInner | MemberExpression<expressionInner>)
}

PrefixExpression {
  !prefix (kw<"void"> | kw<"typeof"> | op<"!"> | op<"++" | "--"> | op<"+" | "-">) expressionNoComma
}

BinaryExpression {
  expressionNoComma !compare op<"<" "="? | ">" "=" | "==" "="? | "!=" "="?> expressionNoComma |
  expressionNoComma !plus op<"+" | "-"> expressionNoComma |
  expressionNoComma !times op<"*" | "/"> expressionNoComma |
  expressionNoComma !and op<"&&"> expressionNoComma |
  expressionNoComma !or op<"||"> expressionNoComma
  // FIXME
}

AssignmentExpression {
  expressionNoComma !assign (op<([+\-/|&%^] | "*" "*"? | "<<" | ">>" ">"?) "="> | op<"=">) expressionNoComma
}

CallExpression {
  expressionNoComma !call ArgList
}

MemberExpression<inner> {
  inner !member ("." Property | "[" expression "]")
}

SuffixExpression {
  expressionNoComma !suffix op<"++" | "--">
}

ArgList {
  "(" commaSep<"..."? expressionNoComma> ")"
}

ArrowFunction {
  Definition "=>" (Block | expression) |
  ParamList "=>" (Block | expression)
}

commaSep<content> {
  "" | content ("," content?)*
}

commaSep1<content> {
  content? ("," content)*
}

kw<word> { specialize<identifier, word, Keyword> }

boolean { specialize<identifier, "true", Boolean> | specialize<identifier, "false", Boolean> }

null { specialize<identifier, "null", Null> }

Property { identifier }

Variable { identifier }

Definition { identifier }

PropertyDefinition { identifier }

Label { identifier }

semi { ";" }

tokens {
  skip { std.whitespace+ | LineComment | BlockComment }

  LineComment { "//" [^\n]* }

  BlockComment { "/*" ([^*] | "*" [^/])* "*/" }

  identifierChar { std.asciiLetter | [_$\u{a1}-\u{10ffff}] }

  identifier { identifierChar (identifierChar | std.digit)* }

  Number {
    (std.digit+ ("." std.digit*)? | "." std.digit+) (("e" | "E") ("+" | "-")? std.digit+)? |
    "0x" (std.digit | [a-fA-F])+ |
    "0b" [01]+ |
    "0o" [0-7]+
  }

  String {
    '"' ([^\\\n"] | "\\" _)* '"'? |
    "'" ([^\\\n'] | "\\" _)* "'"?
  }

  op<expr>=Operator { expr }

  group {
    RegExp { "/" ([^/\\\n[] | "\\" [^\n] | "[" ([^\n\]] | "\\" [^\n])* "]")+ ("/" [gimsuy]*)? }
  }

  group {
    plainStar { "*" }
  }
}
