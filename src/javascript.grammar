precedence {
  statement,
  else left,
  member,
  newArgs,
  call,
  taggedTemplate,
  prefix,
  suffix,
  typeof,
  exp left,
  times left,
  plus left,
  shift left,
  rel left,
  equal left,
  bitOr left,
  bitXor left,
  bitAnd left,
  and left,
  or left,
  ternary left,
  assign left,
  comma left
}

program { statement+ }

statement {
  ExportStatement |
  ImportStatement |
  tag.ForStatement<kw<"for"> "(" forSpec ")" statement> |
  tag.WhileStatement<kw<"while"> parenExpression statement> |
  tag.WithStatement<kw<"with"> parenExpression statement> |
  tag.DoWhileStatement<kw<"do"> statement kw<"while"> parenExpression semi> |
  tag.IfStatement<kw<"if"> parenExpression statement !else (kw<"else"> statement)?> |
  tag.SwitchStatement<kw<"switch"> parenExpression tag.Block<"{" switchItem* "}">> |
  tag.TryStatement<kw<"try"> Block (kw<"catch"> ("(" pattern ")")? Block)? (kw<"finally"> Block)?> |
  tag.ReturnStatement<kw<"return"> expression semi> |
  tag.ThrowStatement<kw<"throw"> expression semi> |
  tag.BreakStatement<kw<"break"> Label? semi> |
  tag.ContinueStatement<kw<"continue"> Label? semi> |
  tag.DebuggerStatement<kw<"debugger"> semi> |
  Block |
  LabeledStatement |
  declaration |
  expression semi |
  semi
}

ExportStatement {
  kw<"export"> plainStar kw<"from"> String semi |
  kw<"export"> kw<"default"> expression semi |
  kw<"export"> declaration semi |
  kw<"export"> ExportGroup (kw<"from"> String)? semi
}

ExportGroup {
  "{" (Variable (kw<"as"> Variable)?)* "}"
}

ImportStatement {
  kw<"import"> (plainStar kw<"as"> Definition | Definition | ImportGroup) kw<"from"> String semi
  kw<"import"> String semi
}

ImportGroup {
  "{" (Definition (kw<"as"> Definition)?)* "}"
}

LabeledStatement {
  Label ":" statement
}

forSpec {
  VariableDeclaration expression? ";" expression? |
  tag.LoopDeclaration<(kw<"let"> | kw<"var"> | kw<"const">) pattern (kw<"in"> | kw<"of">) expression> |
  ";" expression? ";" expression?
}

declaration {
  FunctionDeclaration | ClassDeclaration | VariableDeclaration
}

FunctionDeclaration {
  kw<"function"> Definition plainStar? ParamList Block !statement |
  kw<"async"> kw<"function"> Definition plainStar? ParamList Block
}

ClassDeclaration {
  kw<"class"> Definition (kw<"extends"> expression)? ClassBody !statement
}

ClassBody {
  "{" MethodDefinition* "}"
}

MethodDefinition {
  kw<"static">?
  kw<"async">?
  (kw<"get"> | kw<"set"> | plainStar)?
  PropertyDefinition
  ParamList
  Block
}

VariableDeclaration {
  (kw<"let"> | kw<"var"> | kw<"const">) commaSep1<patternAssign> semi
}

pattern {
  Definition | ArrayPattern | ObjectPattern
}

patternAssign {
  pattern (op<"="> expressionNoComma)?
}

ObjectPattern {
  "{" commaSep<"..."? Property (":" pattern)? (op<"="> expressionNoComma)?> "}"
}

ArrayPattern {
  "[" commaSep<"..." patternAssign | patternAssign> ~arrow "]"
}

ParamList {
  "(" commaSep<"..." patternAssign | patternAssign> ")"
}

parenExpression {
  "(" expression ")"
}

Block {
  !statement "{" statement* "}"
}

switchItem {
  tag.SwitchCase<kw<"case"> expression ":"> |
  tag.SwitchDefault<kw<"default"> ":"> |
  statement
}

expression {
  expressionNoComma | SequenceExpression
}

SequenceExpression {
  expressionNoComma !comma "," expressionNoComma
}

expressionInner {
  Number |
  String |
  TemplateString |
  Variable |
  boolean |
  this |
  null |
  RegExp |
  ArrayExpression |
  NewExpression |
  PrefixExpression |
  "(" expression ")" |
  ClassExpression |
  FunctionExpression |
  ArrowFunction
}

expressionNoComma {
  expressionInner |
  MemberExpression<expressionNoComma> |
  BinaryExpression |
  tag.ConditionalExpression<expressionNoComma !ternary op<"?"> expressionNoComma tag.Operator<":"> expressionNoComma> |
  AssignmentExpression |
  SuffixExpression |
  tag.CallExpression<expressionNoComma !call ArgList> |
  tag.TaggedTemplateExpression<expressionNoComma !taggedTemplate TemplateString>
}

ArrayExpression {
  "[" commaSep1<expressionNoComma | ""> ~arrow "]"
}

ClassExpression {
  kw<"class"> Definition? (kw<"extends"> expression)? ClassBody
}

FunctionExpression {
  kw<"function"> Definition? plainStar? ParamList Block
}

NewExpression {
  kw<"new"> (expressionInner | MemberExpression<expressionInner>) !newArgs ArgList |
  kw<"new"> (expressionInner | MemberExpression<expressionInner>)
}

PrefixExpression {
  !prefix (kw<"yield"> | kw<"void"> | kw<"typeof"> | kw<"delete"> | op<"!"> | op<"~"> | op<"++" | "--"> | op<"+" | "-">) expressionNoComma
}

BinaryExpression {
  expressionNoComma !exp op<"**"> expressionNoComma |
  expressionNoComma !times op<"*" | "/" | "%"> expressionNoComma |
  expressionNoComma !plus op<"+" | "-"> expressionNoComma |
  expressionNoComma !shift op<">>" ">"? | "<<"> expressionNoComma |
  expressionNoComma !rel (op<"<" "="? | ">" "="> | kw<"in"> | kw<"instanceof">) expressionNoComma |
  expressionNoComma !equal op<"==" "="? | "!=" "="?> expressionNoComma |
  expressionNoComma !bitOr op<"|"> expressionNoComma |
  expressionNoComma !bitXor op<"^"> expressionNoComma |
  expressionNoComma !bitAnd op<"&"> expressionNoComma |
  expressionNoComma !and op<"&&"> expressionNoComma |
  expressionNoComma !or op<"||"> expressionNoComma
}

AssignmentExpression {
  expressionNoComma !assign (op<([+\-/|&%^] | "*" "*"? | "<<" | ">>" ">"?) "="> | op<"=">) expressionNoComma
}

MemberExpression<inner> {
  inner !member ("." Property | "[" expression "]")
}

SuffixExpression {
  expressionNoComma !suffix op<"++" | "--">
}

ArgList {
  "(" commaSep<"..."? expressionNoComma> ")"
}

ArrowFunction {
  kw<"async">? (tag.ParamList<Definition> | ParamList) "=>" (Block | expression)
}

TemplateString {
  Template | TemplateStart expression (TemplateContinue expression)* TemplateEnd
}

commaSep<content> {
  "" | content ("," content?)*
}

commaSep1<content> {
  content ("," content)*
}

kw<word> { specialize<identifier, word, Keyword> }

boolean { specialize<identifier, "true", Boolean> | specialize<identifier, "false", Boolean> }

this { specialize<identifier, "this", This> }

null { specialize<identifier, "null", Null> }

Property { identifier }

Variable { identifier ~arrow }

Definition { identifier ~arrow }

PropertyDefinition { identifier }

Label { identifier }

semi { ";" }

tokens {
  skip { std.whitespace+ | LineComment | BlockComment }

  LineComment { "//" [^\n]* }

  BlockComment { "/*" ([^*] | "*" [^/])* "*/" }

  identifierChar { std.asciiLetter | [_$\u{a1}-\u{10ffff}] }

  identifier { identifierChar (identifierChar | std.digit)* }

  Number {
    (std.digit+ ("." std.digit*)? | "." std.digit+) (("e" | "E") ("+" | "-")? std.digit+)? |
    "0x" (std.digit | [a-fA-F])+ |
    "0b" [01]+ |
    "0o" [0-7]+
  }

  String {
    '"' ([^\\\n"] | "\\" _)* '"'? |
    "'" ([^\\\n'] | "\\" _)* "'"?
  }

  // This is a rather cryptic kludge using recursion to be able to
  // match ${ as the end of TemplateStart (and not a valid subsequence in
  // Template) without getting confused by something like $${. It uses
  // recursion to switch between two matching modes, depending on
  // whether the last character was a $. Both modes are expressed by
  // `templateRest` (or `templateStartRest`) with different arguments.

  Template { "`" templateRest<[^$\\`]> }

  templateRest<exclude> {
    "`" |
    "$" templateRest<[^$\\`{]> |
    "\\" _ templateRest<[^$\\`]> |
    exclude templateRest<[^$\\`]>
  }

  TemplateStart=Template { "`" templateStartRest<[^$\\`]> }

  templateStartRest<exclude> {
    "$" ("{" | templateStartRest<[^`${\\]>) |
    "\\" _ templateStartRest<[^$\\`]> |
    exclude templateStartRest<[^$\\`]>
  }

  TemplateContinue=Template { "}" templateStartRest<[^$\\`]> }

  TemplateEnd=Template { "}" templateRest<[^$\\`]> }

  op<expr>=Operator { expr }

  group {
    RegExp { "/" ([^/\\\n[] | "\\" [^\n] | "[" ([^\n\\\]] | "\\" [^\n])* "]")+ ("/" [gimsuy]*)? }
  }

  group {
    plainStar { "*" }
  }
}
