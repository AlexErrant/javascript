precedence {
  else left,
  member,
  newArgs,
  call,
  taggedTemplate,
  prefix,
  postfix,
  typeof,
  exp left,
  times left,
  plus left,
  shift left,
  loop,
  rel left,
  equal left,
  bitOr left,
  bitXor left,
  bitAnd left,
  and left,
  or left,
  ternary left,
  assign left,
  comma left,
  statement cut
}

program { statement+ }

statement {
  ExportDeclaration |
  ImportDeclaration |
  tag.ForStatement<kw<"for"> ckw<"await">? "(" forSpec ")" statement> |
  tag.WhileStatement<kw<"while"> parenExpression statement> |
  tag.WithStatement<kw<"with"> parenExpression statement> |
  tag.DoWhileStatement<kw<"do"> statement kw<"while"> parenExpression semi> |
  tag.IfStatement<kw<"if"> parenExpression statement (!else kw<"else"> statement)?> |
  tag.SwitchStatement<kw<"switch"> parenExpression tag.Block<"{" switchItem* "}">> |
  tag.TryStatement<kw<"try"> Block (kw<"catch"> ("(" pattern ")")? Block)? (kw<"finally"> Block)?> |
  tag.ReturnStatement<kw<"return"> (noSemi expression)? semi> |
  tag.ThrowStatement<kw<"throw"> expression semi> |
  tag.BreakStatement<kw<"break"> (noSemi Label)? semi> |
  tag.ContinueStatement<kw<"continue"> (noSemi Label)? semi> |
  tag.DebuggerStatement<kw<"debugger"> semi> |
  Block |
  LabeledStatement |
  declaration |
  expression semi |
  ";"
}

ExportDeclaration {
  kw<"export"> Star kw<"from"> String semi |
  kw<"export"> kw<"default"> (FunctionDeclaration | ClassDeclaration | expression semi) |
  kw<"export"> declaration |
  kw<"export"> ExportGroup (kw<"from"> String)? semi
}

ExportGroup {
  "{" commaSep<Variable (kw<"as"> tag.Variable<word>)?> "}"
}

ImportDeclaration {
  kw<"import"> (Star kw<"as"> tag.Definition<word> | commaSep<Definition | ImportGroup>) kw<"from"> String semi |
  kw<"import"> String semi
}

ImportGroup {
  "{" commaSep<Definition | Variable kw<"as"> tag.Definition<word>> "}"
}

LabeledStatement {
  Label ":" statement
}

forSpec {
  (VariableDeclaration | expression ";") expression? ";" expression? |
  tag.LoopDeclaration<
    ((kw<"let"> | kw<"var"> | kw<"const">) pattern | Variable | MemberExpression | ArrayPattern | ObjectPattern)
    !loop (kw<"in"> | kw<"of">) expression
  > |
  ";" expression? ";" expression?
}

declaration {
  FunctionDeclaration | ClassDeclaration | VariableDeclaration
}

FunctionDeclaration {
  ckw<"async">? !statement kw<"function"> Star? Definition? ParamList Block
}

ClassDeclaration {
  !statement kw<"class"> Definition (kw<"extends"> expression)? ClassBody
}

ClassBody {
  "{" (MethodDefinition | ";")* "}"
}

MethodDefinition {
  pkw<"static">?
  pkw<"async">?
  (pkw<"get"> | pkw<"set"> | Star)?
  PropertyName
  ParamList
  Block
}

VariableDeclaration {
  (kw<"let"> | kw<"var"> | kw<"const">) commaSep1<patternAssign> semi
}

pattern { Definition | ArrayPattern | ObjectPattern }

ArrayPattern { "[" commaSep<"..." patternAssign | patternAssign> ~destructure "]" }

ObjectPattern { "{" commaSep<patternProperty> ~destructure "}" }

patternAssign {
  pattern (op<"="> expressionNoComma)?
}

ParamList {
  "(" commaSep<"..." patternAssign | patternAssign> ")"
}

parenExpression {
  "(" expression ")"
}

Block {
  !statement "{" statement* "}"
}

switchItem {
  tag.SwitchCase<kw<"case"> expression ":"> |
  tag.SwitchDefault<kw<"default"> ":"> |
  statement
}

expression {
  expressionNoComma | SequenceExpression
}

SequenceExpression {
  expressionNoComma !comma "," expressionNoComma
}

expressionNoComma {
  Number |
  String |
  TemplateString |
  Variable |
  boolean |
  this |
  null |
  super |
  RegExp |
  ArrayExpression |
  tag.ObjectExpression<"{" commaSep<Property> ~destructure "}"> |
  NewExpression |
  UnaryExpression |
  "(" expression ")" |
  ClassExpression |
  FunctionExpression |
  ArrowFunction |
  MemberExpression |
  BinaryExpression |
  tag.ConditionalExpression<expressionNoComma !ternary op<"?"> expressionNoComma tag.Operator<":"> expressionNoComma> |
  AssignmentExpression |
  tag.UnaryExpression<expressionNoComma !postfix postfixOp> |
  tag.CallExpression<expressionNoComma !call ArgList> |
  tag.TaggedTemplateExpression<expressionNoComma !taggedTemplate TemplateString>
}

ArrayExpression {
  "[" commaSep1<expressionNoComma | ""> ~destructure "]"
}

propName { PropertyName | "[" expression "]" | Number | String }

Property {
  pkw<"async">? (pkw<"get"> | pkw<"set"> | Star)? propName ParamList Block |
  propName ~destructure (":" expressionNoComma)? |
  "..." expressionNoComma
}

patternProperty=Property {
  "..." patternAssign |
  (PropertyName | Number | String) ~destructure (":" pattern)? (op<"="> expressionNoComma)?
}

ClassExpression {
  kw<"class"> Definition? (kw<"extends"> expression)? ClassBody
}

FunctionExpression {
  kw<"function"> Star? Definition? ParamList Block
}

NewExpression {
  kw<"new"> expressionNoComma (!newArgs ArgList)?
}

UnaryExpression {
  !prefix (ckw<"await"> | ckw<"yield"> | kw<"void"> | kw<"typeof"> | kw<"delete"> | op<"!"> | op<"~"> | op<"++" | "--"> | op<"+" | "-">)
  expressionNoComma
}

BinaryExpression {
  expressionNoComma !exp op<"**"> expressionNoComma |
  expressionNoComma !times (divide | op<"%"> | tag.Operator<"*">) expressionNoComma |
  expressionNoComma !plus op<"+" | "-"> expressionNoComma |
  expressionNoComma !shift op<">>" ">"? | "<<"> expressionNoComma |
  expressionNoComma !rel (op<"<" "="? | ">" "="?> | kw<"in"> | kw<"instanceof">) expressionNoComma |
  expressionNoComma !equal op<"==" "="? | "!=" "="?> expressionNoComma |
  expressionNoComma !bitOr op<"|"> expressionNoComma |
  expressionNoComma !bitXor op<"^"> expressionNoComma |
  expressionNoComma !bitAnd op<"&"> expressionNoComma |
  expressionNoComma !and op<"&&"> expressionNoComma |
  expressionNoComma !or op<"||"> expressionNoComma
}

AssignmentExpression {
  (Variable | MemberExpression) !assign op<([+\-/|&%^] | "*" "*"? | "<<" | ">>" ">"?) "="> expressionNoComma |
  (Variable | MemberExpression | ArrayPattern | ObjectPattern) !assign op<"="> expressionNoComma
}

MemberExpression {
  expressionNoComma !member ("." PropertyName | "[" expression "]")
}

ArgList {
  "(" commaSep<"..."? expressionNoComma> ")"
}

ArrowFunction {
  ckw<"async">? (tag.ParamList<Definition> | ParamList) "=>" (Block | expression)
}

skip {} {
  TemplateString {
    templateStart (templateContent | templateExpr)* templateEnd
  }
}

templateExpr { templateDollarBrace expression "}" }

commaSep<content> {
  "" | content ("," content?)*
}

commaSep1<content> {
  content ("," content)*
}

kw<term> { specialize<identifier, term, Keyword> }

// Contextual keywords
ckw<term> { extend<identifier, term, Keyword> }

// Contextual keyword in property context
pkw<term> { extend<word, term, Keyword> }

semi { ";" | insertSemi }

boolean { specialize<identifier, "true", Boolean> | specialize<identifier, "false", Boolean> }

this { specialize<identifier, "this", This> }

null { specialize<identifier, "null", Null> }

super { specialize<identifier, "super", Super> }

Star { "*" }

Variable { identifier ~arrow }

Definition { identifier ~arrow }

Label { identifier }

PropertyName { word }

skip { whitespace | LineComment | BlockComment }

external tokens noSemicolon from "./semicolon" { noSemi }

external tokens postfix from "./semicolon" { postfixOp=Operator }

tokens {
  whitespace { std.whitespace+ }

  LineComment=Comment { "//" [^\n]* }

  BlockComment=Comment { "/*" blockCommentRest }

  blockCommentRest { [^*] blockCommentRest | "*" blockCommentAfterStar }

  blockCommentAfterStar { "/" | "*" blockCommentAfterStar | [^/*] blockCommentRest }

  divide=Operator { "/" }

  precedence { BlockComment, LineComment, divide }

  precedence { BlockComment, LineComment, RegExp }

  identifierChar { std.asciiLetter | [_$\u{a1}-\u{10ffff}] }

  word { identifierChar (identifierChar | std.digit)* }

  identifier { word }

  precedence { identifier, whitespace }

  precedence { word, whitespace }

  Number {
    (std.digit+ ("." std.digit*)? | "." std.digit+) (("e" | "E") ("+" | "-")? std.digit+)? |
    "0x" (std.digit | [a-fA-F])+ |
    "0b" [01]+ |
    "0o" [0-7]+
  }

  String {
    '"' ([^\\\n"] | "\\" _)* '"'? |
    "'" ([^\\\n'] | "\\" _)* "'"?
  }

  templateStart=Template { "`" }

  op<expr>=Operator { expr }

  RegExp { "/" ([^/\\\n[] | "\\" [^\n] | "[" ([^\n\\\]] | "\\" [^\n])* "]")+ ("/" [gimsuy]*)? }
}

external tokens insertSemicolon from "./semicolon" { insertSemi }

external tokens template from "./template" {
  templateContent=Template,
  templateDollarBrace,
  templateEnd=Template
}
