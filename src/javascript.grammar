@precedence {
  else @left,
  member,
  newArgs,
  call,
  taggedTemplate,
  prefix,
  postfix,
  typeof,
  exp @left,
  times @left,
  plus @left,
  shift @left,
  loop,
  rel @left,
  equal @left,
  bitOr @left,
  bitXor @left,
  bitAnd @left,
  and @left,
  or @left,
  ternary @left,
  assign @left,
  comma @left,
  statement @cut
}

@top[name=Script,lang=javascript] { statement+ }

statement {
  ExportDeclaration |
  ImportDeclaration |
  ForStatement { kwCtrl<"for"> ckwOp<"await">? (ForSpec | ForInSpec | ForOfSpec) statement } |
  WhileStatement { kwCtrl<"while"> ParenthesizedExpression statement } |
  WithStatement { kw<"with"> ParenthesizedExpression statement } |
  DoStatement { kwCtrl<"do"> statement kwCtrl<"while"> ParenthesizedExpression semi } |
  IfStatement { kwCtrl<"if"> ParenthesizedExpression statement (!else kwCtrl<"else"> statement)? } |
  SwitchStatement { kwCtrl<"switch"> ParenthesizedExpression Block { "{" switchItem* "}" } } |
  TryStatement { kwCtrl<"try"> Block (kwCtrl<"catch"> ("(" pattern ")")? Block)? (kwCtrl<"finally"> Block)? } |
  ReturnStatement { kwCtrl<"return"> (noSemi expression)? semi } |
  ThrowStatement { kwCtrl<"throw"> expression semi } |
  BreakStatement { kwCtrl<"break"> (noSemi Label)? semi } |
  ContinueStatement { kwCtrl<"continue"> (noSemi Label)? semi } |
  DebuggerStatement { kw<"debugger"> semi } |
  Block |
  LabeledStatement { Label ":" statement } |
  declaration |
  ExpressionStatement { expression semi } |
  ";"
}

ExportDeclaration {
  kwDef<"export"> Star ckw<"from"> String semi |
  kwDef<"export"> kwCtrl<"default"> (FunctionDeclaration | ClassDeclaration | expression semi) |
  kwDef<"export"> declaration |
  kwDef<"export"> ExportGroup (ckw<"from"> String)? semi
}

ExportGroup {
  "{" commaSep<VariableName (ckw<"as"> VariableName { word })?> "}"
}

ImportDeclaration {
  kwDef<"import"> (Star ckw<"as"> VariableDefinition | commaSep<VariableDefinition | ImportGroup>) ckw<"from"> String semi |
  kwDef<"import"> String semi
}

ImportGroup {
  "{" commaSep<VariableDefinition | VariableName ckw<"as"> VariableDefinition> "}"
}

ForSpec {
  "("
  (VariableDeclaration | expression ";" | ";") expression? ";" expression?
  ")"
}

forXSpec<op> {
  "("
  ((kwDef<"let"> | kwDef<"var"> | kwDef<"const">) pattern | VariableName | MemberExpression | ArrayPattern | ObjectPattern)
  !loop op expression
  ")"
}

ForInSpec { forXSpec<kwOp<"in">> }
ForOfSpec { forXSpec<ckwOp<"of">> }

declaration {
  FunctionDeclaration | ClassDeclaration | VariableDeclaration
}

FunctionDeclaration {
  async? !statement kwDef<"function"> Star? VariableDefinition? ParamList Block
}

ClassDeclaration {
  !statement kwDef<"class"> VariableDefinition (kwDef<"extends"> expression)? ClassBody
}

ClassBody {
  "{" (MethodDeclaration | ";")* "}"
}

MethodDeclaration {
  pkwMod<"static">?
  pkwMod<"async">?
  (pkwMod<"get"> | pkwMod<"set"> | Star)?
  PropertyNameDefinition
  ParamList
  Block
}

VariableDeclaration {
  (kwDef<"let"> | kwDef<"var"> | kwDef<"const">) commaSep1<patternAssign> semi
}

pattern { VariableDefinition | ArrayPattern | ObjectPattern }

ArrayPattern { "[" commaSep<"..." patternAssign | patternAssign> ~destructure "]" }

ObjectPattern { "{" commaSep<PatternProperty> ~destructure "}" }

patternAssign {
  pattern ("=" expressionNoComma)?
}

ParamList {
  "(" commaSep<"..." patternAssign | patternAssign> ")"
}

Block {
  !statement "{" statement* "}"
}

switchItem {
  CaseLabel { kwCtrl<"case"> expression ":" } |
  DefaultLabel { kwCtrl<"default"> ":" } |
  statement
}

expression {
  expressionNoComma | SequenceExpression
}

SequenceExpression {
  expressionNoComma !comma ("," expressionNoComma)+
}

expressionNoComma {
  Number |
  String |
  TemplateString |
  VariableName |
  boolean |
  this |
  null |
  super |
  RegExp |
  ArrayExpression |
  ObjectExpression { "{" commaSep<Property> ~destructure "}" } |
  NewExpression |
  UnaryExpression |
  ParenthesizedExpression |
  ClassExpression |
  FunctionExpression |
  ArrowFunction |
  MemberExpression |
  BinaryExpression |
  ConditionalExpression { expressionNoComma !ternary LogicOp<"?"> expressionNoComma LogicOp<":"> expressionNoComma } |
  AssignmentExpression |
  PostfixExpression { expressionNoComma !postfix PostfixOp } |
  CallExpression { expressionNoComma !call ArgList } |
  TaggedTemplatExpression { expressionNoComma !taggedTemplate TemplateString }
}

ParenthesizedExpression { "(" expression ")" }

ArrayExpression {
  "[" commaSep1<expressionNoComma | ""> ~destructure "]"
}

propName { PropertyNameDefinition | "[" expression "]" | Number | String }

Property {
  pkwMod<"async">? (pkwMod<"get"> | pkwMod<"set"> | Star)? propName ParamList Block |
  propName ~destructure (":" expressionNoComma)? |
  "..." expressionNoComma
}

PatternProperty {
  "..." patternAssign |
  (PropertyName | Number | String) ~destructure (":" pattern)? ("=" expressionNoComma)?
}

ClassExpression {
  kwDef<"class"> VariableDefinition? (kwDef<"extends"> expression)? ClassBody
}

FunctionExpression {
  kwDef<"function"> Star? VariableDefinition? ParamList Block
}

NewExpression {
  kwOp<"new"> expressionNoComma (!newArgs ArgList)?
}

UnaryExpression {
  !prefix (ckwOp<"await"> | ckwOp<"yield"> | kwOp<"void"> | kwOp<"typeof"> | kwOp<"delete"> |
           LogicOp<"!"> | BitOp<"~"> | ArithOp<"++" | "--"> | ArithOp<"+" | "-">)
  expressionNoComma
}

BinaryExpression {
  expressionNoComma !exp ArithOp<"**"> expressionNoComma |
  expressionNoComma !times (divide | ArithOp<"%"> | ArithOp<"*">) expressionNoComma |
  expressionNoComma !plus ArithOp<"+" | "-"> expressionNoComma |
  expressionNoComma !shift BitOp<">>" ">"? | "<<"> expressionNoComma |
  expressionNoComma !rel (CompareOp<"<" "="? | ">" "="?> | kwOp<"in"> | kwOp<"instanceof">) expressionNoComma |
  expressionNoComma !equal CompareOp<"==" "="? | "!=" "="?> expressionNoComma |
  expressionNoComma !bitOr BitOp<"|"> expressionNoComma |
  expressionNoComma !bitXor BitOp<"^"> expressionNoComma |
  expressionNoComma !bitAnd BitOp<"&"> expressionNoComma |
  expressionNoComma !and LogicOp<"&&"> expressionNoComma |
  expressionNoComma !or LogicOp<"||"> expressionNoComma
}

AssignmentExpression {
  (VariableName | MemberExpression) !assign UpdateOp<($[+\-/|&%^] | "*" "*"? | "<<" | ">>" ">"?) "="> expressionNoComma |
  (VariableName | MemberExpression | ArrayPattern | ObjectPattern) !assign "=" expressionNoComma
}

MemberExpression {
  expressionNoComma !member ("." PropertyName | "[" expression "]")
}

ArgList {
  "(" commaSep<"..."? expressionNoComma> ")"
}

ArrowFunction {
  async? (ParamList { VariableDefinition } | ParamList) "=>" (Block | expression)
}

@skip {} {
  TemplateString[style=literal.string.special] {
    templateStart (templateContent | templateExpr)* templateEnd
  }
}

templateExpr { templateDollarBrace expression templateClosingBrace }

commaSep<content> {
  "" | content ("," content?)*
}

commaSep1<content> {
  content ("," content)*
}

// Keywords

kw<term> { @specialize[name={term},style=keyword]<identifier, term> }

kwCtrl<term> { @specialize[name={term},style=keyword.control]<identifier, term> }

kwOp<term> { @specialize[name={term},style=keyword.operator]<identifier, term> }

kwDef<term> { @specialize[name={term},style=keyword.define]<identifier, term> }

// Contextual keywords

ckw<term> { @extend[name={term},style=keyword]<identifier, term> }

ckwOp<term> { @extend[name={term},style=keyword.operator]<identifier, term> }

async { @extend[name=async,style=keyword.modifier]<identifier, "async"> }

// Contextual keyword in property context

pkwMod<term> { @extend[name={term},style=keyword.modifier]<word, term> }

semi { ";" | insertSemi }

boolean { @specialize[name=BooleanLiteral,style=keyword.expression]<identifier, "true" | "false"> }

this { @specialize[name=This,style=keyword.expression.self]<identifier, "this"> }

null { @specialize[name=Null,style=keyword.expression.null]<identifier, "null"> }

super { @specialize[name=Super,style=keyword.expression]<identifier, "super"> }

Star[style=punctuation.marker] { "*" }

VariableName[style=name.variable] { identifier ~arrow }

VariableDefinition[style=name.variable.define] { identifier ~arrow }

Label[style=name.label] { identifier }

PropertyName[style=name.property] { word }

PropertyNameDefinition[style=name.property.define] { word }

@skip { whitespace | LineComment | BlockComment }

@external tokens noSemicolon from "./tokens" { noSemi }

@external tokens postfix from "./tokens" { PostfixOp[style=operator.update] }

@tokens {
  whitespace { std.whitespace+ }

  LineComment[style=comment.line] { "//" ![\n]* }

  BlockComment[style=comment.block] { "/*" blockCommentRest }

  blockCommentRest { ![*] blockCommentRest | "*" blockCommentAfterStar }

  blockCommentAfterStar { "/" | "*" blockCommentAfterStar | ![/*] blockCommentRest }

  divide[name=ArithOp,style=operator.arithmetic] { "/" }

  @precedence { BlockComment, LineComment, divide }

  @precedence { BlockComment, LineComment, RegExp }

  identifierChar { std.asciiLetter | $[_$\u{a1}-\u{10ffff}] }

  word { identifierChar (identifierChar | std.digit)* }

  identifier { word }

  @precedence { identifier, whitespace }

  @precedence { word, whitespace }

  Number[style=literal.number] {
    (std.digit+ ("." std.digit*)? | "." std.digit+) (("e" | "E") ("+" | "-")? std.digit+)? |
    "0x" (std.digit | $[a-fA-F])+ |
    "0b" $[01]+ |
    "0o" $[0-7]+
  }

  String[style=literal.string] {
    '"' (![\\\n"] | "\\" _)* '"'? |
    "'" (![\\\n'] | "\\" _)* "'"?
  }

  templateStart { "`" }

  templateClosingBrace { "}" }

  ArithOp[style=operator.arithmetic]<expr> { expr }
  LogicOp[style=operator.logic]<expr> { expr }
  BitOp[style=operator.bitwise]<expr> { expr }
  CompareOp[style=operator.compare]<expr> { expr }
  UpdateOp[style=operator.update]<expr> { expr }

  RegExp[style=literal.regexp] { "/" (![/\\\n[] | "\\" ![\n] | "[" (![\n\\\]] | "\\" ![\n])* "]")+ ("/" $[gimsuy]*)? }

  "="[name=Equals,style=operator.define]
  "..."[name=Spread, style=punctuation.modifier]
  "=>"[name=Arrow, style=punctuation.define]

  "("[style=bracket.paren.open]
  ")"[style=bracket.paren.close]
  "["[style=bracket.square.open]
  "]"[style=bracket.square.close]
  "{"[style=bracket.brace.open]
  "}"[style=bracket.brace.close]

  "."[style=operator.deref]
  ","[style=punctuation.separator]
  ";"[style=punctuation.separator]
  ":"[style=punctuation.define]
}

@external tokens insertSemicolon from "./tokens" { insertSemi }

@external tokens template from "./tokens" {
  templateContent,
  templateDollarBrace,
  templateEnd
}

@detectDelim
